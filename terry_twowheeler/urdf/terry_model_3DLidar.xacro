<?xml version="1.0" ?>
<!-- =================================================================================== -->
<!-- |    This document was autogenerated by xacro from diff_wheeled_robot.xacro       | -->
<!-- |    EDITING THIS FILE BY HAND IS NOT RECOMMENDED                                 | -->
<!-- =================================================================================== -->
<robot name="terry" xmlns:xacro="http://www.ros.org/wiki/xacro">

  <!-- PROPERTY LIST -->

  <!-- Constants -->
  <xacro:property name="PI" value="3.1415926535897931"/>
  <xacro:property name="density" value="1000"/> <!-- kg/m^3 -->

  <!-- Chassis dimensions -->
  <xacro:property name="rChassis" value="0.2" />  <!-- meters -->
  <xacro:property name="hChassis" value="0.1" /> <!-- meters -->
  <xacro:property name="mChassis" value="${density * PI * rChassis * rChassis * hChassis}" /> <!-- kg -->

  <!-- Wheel dimensions -->
  <xacro:property name="rWheel" value="0.1" />
  <xacro:property name="hWheel" value="0.05" />
  <xacro:property name="mWheel" value="${density * PI * rWheel * rWheel * hWheel}" />

  <!-- Caster wheel (sphere) dimensions -->
  <xacro:property name="rCaster" value="${(rWheel - hChassis/2.0) / 2.0}" />
  <xacro:property name="mCaster" value="${density * (4/3) * PI * rCaster * rCaster}" />

  <!-- Camera dimensions, square -->
  <xacro:property name="sCamera" value="0.03" />
  <xacro:property name="mCamera" value="0.02" />

  <!-- Lidar dimensions -->
  <xacro:property name="rLidar" value="0.025" />  <!-- meters -->
  <xacro:property name="hLidar" value="0.03" /> <!-- half height, meters -->
  <xacro:property name="mLidar" value="0.05" /> <!-- total mass, kg -->

  <!-- Frictions of joints -->
  <xacro:property name="friction_wheel_joints" value="0.1" />   <!-- N.m -->
  <xacro:property name="friction_caster_joints" value="0.05" /> <!-- N.m -->

  <!-- BASE-FOOTPRINT -->
  <!-- base_footprint is a fictitious link(frame) that is on the ground right below base_link origin -->
  <link name="base_footprint">
    <!--<inertial>
      <mass value="0.0001"/>
      <origin xyz="0 0 0"/>
      <inertia ixx="0.0001" ixy="0.0" ixz="0.0" iyy="0.0001" iyz="0.0" izz="0.0001"/>
    </inertial>
    <visual>
      <origin rpy="0 0 0" xyz="0 0 0"/>
      <geometry>
        <box size="0.001 0.001 0.001"/>
      </geometry>
    </visual>-->
  </link>
  <!--<gazebo reference="base_footprint">
    <turnGravityOff>true</turnGravityOff>
  </gazebo>-->
  <joint name="base_footprint_joint" type="fixed">
    <origin rpy="0 0 0" xyz="0 0 ${rWheel}"/>
    <parent link="base_footprint"/>
    <child link="base_link"/>
  </joint>

  <!-- BASE-LINK -->
  <!--Actual body/chassis of the robot-->
  <link name="base_link">
    <inertial>
      <origin rpy="0 0 0" xyz="0 0 0"/>
      <mass value="${mChassis}"/>
      <inertia
        ixx="${mChassis / 12.0 * (3*rChassis*rChassis + hChassis*hChassis)}" ixy="0.0" ixz="0.0"
        iyy="${mChassis / 12.0 * (3*rChassis*rChassis + hChassis*hChassis)}" iyz="0.0"
        izz="${mChassis / 2.0 * (rChassis*rChassis)}"/>
    </inertial>
    <visual>
      <origin rpy="0 0 0" xyz="0 0 0"/>
      <geometry>
        <cylinder length="${hChassis}" radius="${rChassis}"/>
      </geometry>
    </visual>
    <collision>
      <origin rpy="0 0 0 " xyz="0 0 0"/>
      <geometry>
        <cylinder length="${hChassis}" radius="${rChassis}"/>
      </geometry>
    </collision>
  </link>
  <gazebo reference="base_link">
    <material>Gazebo/White</material>
    <turnGravityOff>false</turnGravityOff>
  </gazebo>

  <!--fb : front, back ; lr: left, right -->
  <link name="front_right_wheel">
    <visual>
      <origin rpy="${PI/2} 0  0 " xyz="0 0 0"/>
      <geometry>
        <cylinder length="${hWheel}" radius="${rWheel}"/>
      </geometry>
    </visual>
    <collision>
      <origin rpy="${PI/2} 0 0 " xyz="0 0 0"/>
      <geometry>
        <cylinder length="${hWheel}" radius="${rWheel}"/>
      </geometry>
    </collision>
    <inertial>
      <origin xyz="0 0 0"/>
      <mass value="${mWheel}"/>
      <inertia
        ixx="${mWheel / 12.0 * (3*rWheel*rWheel + hWheel*hWheel)}" ixy="0.0" ixz="0.0"
        iyy="${mWheel / 12.0 * (3*rWheel*rWheel + hWheel*hWheel)}" iyz="0.0"
        izz="${mWheel / 2.0 * (rWheel*rWheel)}"/>
    </inertial>
  </link>

  <gazebo reference="front_right_wheel">
    <!-- We will assume these values are unknown -->
    <!--<mu1 value="1.0"/>
    <mu2 value="1.0"/>
    <kp value="10000000.0"/>
    <kd value="1.0"/>
    <fdir1 value="1 0 0"/>-->
    <material>Gazebo/Black</material>
    <turnGravityOff>false</turnGravityOff>
  </gazebo>

  <joint name="right_wheel_joint" type="continuous">
    <parent link="base_link"/>
    <child link="front_right_wheel"/>
    <origin rpy="0 0 0" xyz="0.0 ${rChassis + hWheel/2.0} 0.0"/>
    <axis rpy="0 0 0" xyz="0 1 0"/>
    <limit effort="100" velocity="100"/>
    <joint_properties damping="0.0" friction="${friction_wheel_joints}"/>
  </joint>

  <!-- Transmission is important to link the joints and the controller -->
  <transmission name="right_wheel_joint_trans">
    <type>transmission_interface/SimpleTransmission</type>
    <joint name="right_wheel_joint"> 
      <hardwareInterface>EffortJointInterface</hardwareInterface>
    </joint>
    <actuator name="right_wheel_joint_motor">
      <hardwareInterface>EffortJointInterface</hardwareInterface>
      <mechanicalReduction>1</mechanicalReduction>
    </actuator>
  </transmission>

  <!--fb : front, back ; lr: left, right -->
  <link name="front_left_wheel">
    <visual>
      <origin rpy="${PI/2} 0  0 " xyz="0 0 0"/>
      <geometry>
        <cylinder length="${hWheel}" radius="${rWheel}"/>
      </geometry>
    </visual>
    <collision>
      <origin rpy="${PI/2} 0 0 " xyz="0 0 0"/>
      <geometry>
        <cylinder length="${hWheel}" radius="${rWheel}"/>
      </geometry>
    </collision>
    <inertial>
      <origin xyz="0 0 0"/>
      <mass value="${mWheel}"/>
      <inertia
        ixx="${mWheel / 12.0 * (3*rWheel*rWheel + hWheel*hWheel)}" ixy="0.0" ixz="0.0"
        iyy="${mWheel / 12.0 * (3*rWheel*rWheel + hWheel*hWheel)}" iyz="0.0"
        izz="${mWheel / 2.0 * (rWheel*rWheel)}"/>
    </inertial>
  </link>

  <gazebo reference="front_left_wheel">
    <!-- We will assume these values are unknown -->
    <!--<mu1 value="1.0"/>
    <mu2 value="1.0"/>
    <kp value="10000000.0"/>
    <kd value="1.0"/>
    <fdir1 value="1 0 0"/>-->
    <material>Gazebo/Black</material>
    <turnGravityOff>false</turnGravityOff>
  </gazebo>

  <joint name="left_wheel_joint" type="continuous">
    <parent link="base_link"/>
    <child link="front_left_wheel"/>
    <origin rpy="0 0 0" xyz="0.0 ${-rChassis - hWheel/2.0} 0.0"/>
    <axis rpy="0 0 0" xyz="0 1 0"/>
    <limit effort="100" velocity="100"/>
    <joint_properties damping="0.0" friction="${friction_wheel_joints}"/>
  </joint>
  <!-- Transmission is important to link the joints and the controller -->
  <transmission name="left_wheel_joint_trans">
    <type>transmission_interface/SimpleTransmission</type>
    <joint name="left_wheel_joint">
      <hardwareInterface>EffortJointInterface</hardwareInterface>
    </joint>
    <actuator name="left_wheel_joint_motor">
      <hardwareInterface>EffortJointInterface</hardwareInterface>
      <mechanicalReduction>1</mechanicalReduction>
    </actuator>
  </transmission>

  <!--Caster front  -->
  <link name="caster_front_link">
    <visual>
      <origin rpy="0 0 0" xyz="0 0 0"/>
      <geometry>
        <sphere radius="${rCaster}"/>
      </geometry>
    </visual>
    <collision>
      <geometry>
        <sphere radius="${rCaster}"/>
      </geometry>
      <origin rpy="0 0 0" xyz="0 0 0"/>
    </collision>
    <inertial>
      <origin xyz="0 0 0"/>
      <mass value="${mCaster}"/>
      <inertia
        ixx="${2.0*mCaster / 5.0 * (rCaster*rCaster)}" ixy="0.0" ixz="0.0"
        iyy="${2.0*mCaster / 5.0 * (rCaster*rCaster)}" iyz="0.0"
        izz="${2.0*mCaster / 5.0 * (rCaster*rCaster)}"/>
    </inertial>
  </link>
  <joint name="caster_front_joint" type="fixed">
    <parent link="base_link"/>
    <child link="caster_front_link"/>
    <origin rpy="0 0 0" xyz="${0.5 * rChassis} 0 ${-hChassis/2.0 - rCaster}"/>
  </joint>
  <gazebo reference="caster_front_link">
    <material>Gazebo/Blue</material>
    <turnGravityOff>false</turnGravityOff>
  </gazebo>

  <!-- Make the caster a spherical joint -->
  <link name="caster_front_link_x" />
  <joint name="caster_front_joint_x" type="continuous" >
      <parent link="caster_front_link" />
      <child link="caster_front_link_x" />
      <axis xyz="1 0 0" />
      <limit effort="100" velocity="100"/>
      <joint_properties damping="0.0" friction="${friction_caster_joints/3.0}"/>
  </joint>
  <link name="caster_front_link_y" />
  <joint name="caster_front_joint_y" type="continuous" >
      <parent link="caster_front_link_x" />
      <child link="caster_front_link_y" />
      <axis xyz="0 1 0" />
      <limit effort="100" velocity="100"/>
      <joint_properties damping="0.0" friction="${friction_caster_joints/3.0}"/>
  </joint>
  <link name="caster_front_link_z" />
  <joint name="caster_front_joint_z" type="continuous" >
      <parent link="caster_front_link_y" />
      <child link="caster_front_link_z" />
      <axis xyz="0 0 1" />
      <limit effort="100" velocity="100"/>
      <joint_properties damping="0.0" friction="${friction_caster_joints/3.0}"/>
  </joint>

  <!--Caster back  -->
  <link name="caster_back_link">
    <visual>
      <origin rpy="0 0 0" xyz="0 0 0"/>
      <geometry>
        <sphere radius="${rCaster}"/>
      </geometry>
    </visual>
    <collision>
      <geometry>
        <sphere radius="${rCaster}"/>
      </geometry>
      <origin rpy="0 0 0" xyz="0 0 0"/>
    </collision>
    <inertial>
      <origin xyz="0 0 0"/>
      <mass value="${mCaster}"/>
      <inertia
        ixx="${2.0*mCaster / 5.0 * (rCaster*rCaster)}" ixy="0.0" ixz="0.0"
        iyy="${2.0*mCaster / 5.0 * (rCaster*rCaster)}" iyz="0.0"
        izz="${2.0*mCaster / 5.0 * (rCaster*rCaster)}"/>
    </inertial>
  </link>
  <joint name="caster_back_joint" type="fixed">
    <parent link="base_link"/>
    <child link="caster_back_link"/>
    <origin rpy="0 0 0" xyz="${-0.5 * rChassis} 0 ${-hChassis/2.0 - rCaster}"/>
  </joint>
  <gazebo reference="caster_back_link">
    <material>Gazebo/Blue</material>
    <turnGravityOff>false</turnGravityOff>
  </gazebo>

  <!-- Make the caster a spherical joint -->
  <link name="caster_back_link_x" />
  <joint name="caster_back_joint_x" type="continuous" >
      <parent link="caster_back_link" />
      <child link="caster_back_link_x" />
      <axis xyz="1 0 0" />
      <limit effort="100" velocity="100"/>
      <joint_properties damping="0.0" friction="${friction_caster_joints/3.0}"/>
  </joint>
  <link name="caster_back_link_y" />
  <joint name="caster_back_joint_y" type="continuous" >
      <parent link="caster_back_link_x" />
      <child link="caster_back_link_y" />
      <axis xyz="0 1 0" />
      <limit effort="100" velocity="100"/>
      <joint_properties damping="0.0" friction="${friction_caster_joints/3.0}"/>
  </joint>
  <link name="caster_back_link_z" />
  <joint name="caster_back_joint_z" type="continuous" >
      <parent link="caster_back_link_y" />
      <child link="caster_back_link_z" />
      <axis xyz="0 0 1" />
      <limit effort="100" velocity="100"/>
      <joint_properties damping="0.0" friction="${friction_caster_joints/3.0}"/>
  </joint>

  <!-- SENSORS -->

  <!-- Camera -->

  <link name="camera_link">
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <box size="${sCamera} ${sCamera} ${sCamera}"/>
      </geometry>
    </collision>

    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <box size="${sCamera} ${sCamera} ${sCamera}"/>
      </geometry>
    </visual>

    <inertial>
      <mass value="${mCamera}" />
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <inertia ixx="${mCamera/12.0 * (2*sCamera*sCamera)}" ixy="0" ixz="0" 
        iyy="${mCamera/12.0 * (2*sCamera*sCamera)}" iyz="0" 
        izz="${mCamera/12.0 * (2*sCamera*sCamera)}" />
    </inertial>
  </link>

  <joint name="camera_joint" type="fixed">
    <parent link="base_link"/>
    <child link="camera_link"/>
    <origin xyz="${rChassis/2.0 + 0.02} 0.1 ${hChassis/2 + sCamera/2.0}" rpy="0 0 0"/>
  </joint>

  <gazebo reference="camera_link">
    <material>Gazebo/Red</material>
  </gazebo>

  <gazebo reference="camera_link">
    <sensor type="camera" name="camera">
      <update_rate>30.0</update_rate>
      <camera name="head">
        <horizontal_fov>1.3962634</horizontal_fov>
        <image>
          <width>800</width>
          <height>800</height>
          <format>R8G8B8</format>
        </image>
        <clip>
          <near>0.02</near>
          <far>300</far>
        </clip>
        <noise>
          <type>gaussian</type>
          <!-- Noise is sampled independently per pixel on each frame.
               That pixel's noise value is added to each of its color
               channels, which at that point lie in the range [0,1]. -->
          <mean>0.0</mean>
          <stddev>0.007</stddev>
        </noise>
      </camera>
      <plugin name="camera_controller" filename="libgazebo_ros_camera.so">
        <alwaysOn>true</alwaysOn>
        <updateRate>0.0</updateRate>
        <cameraName>terry_camera</cameraName>
        <imageTopicName>/terry/image_raw</imageTopicName>
        <cameraInfoTopicName>/terry/camera_info</cameraInfoTopicName>
        <frameName>camera_link</frameName>
        <!-- setting hackBaseline to anything but 0.0 will cause a misalignment
            between the gazebo sensor image and the frame it is supposed to
            be attached to -->
        <hackBaseline>0.07</hackBaseline>
        <distortionK1>0.0</distortionK1>
        <distortionK2>0.0</distortionK2>
        <distortionK3>0.0</distortionK3>
        <distortionT1>0.0</distortionT1>
        <distortionT2>0.0</distortionT2>
        <CxPrime>0</CxPrime>
        <Cx>0.0</Cx>
        <Cy>0.0</Cy>
        <focalLength>0.0</focalLength>
      </plugin>
    </sensor>
  </gazebo>

  <!-- IMU -->
  <link name="imu_link" />

  <joint name="imu_joint" type="fixed">
    <parent link="base_link" />
    <child link="imu_link" />
    <origin rpy="0 0 0" xyz="0 0 0"/>
  </joint>

  <gazebo>
    <plugin name="imu_plugin" filename="libgazebo_ros_imu.so">
      <alwaysOn>true</alwaysOn>
      <bodyName>imu_link</bodyName>
      <topicName>/terry/imu</topicName>
      <serviceName>imu_service</serviceName>
      <gaussianNoise>1e-06</gaussianNoise>
      <updateRate>20.0</updateRate>
    </plugin>
  </gazebo>

    <!-- Lidar -->
    <!-- Modeled after Velodyne HDL32 lidar -->
    <link name="lidar_base_link">
      <inertial>
        <origin rpy="0 0 0" xyz="0 0 0"/>
        <mass value="${mLidar/2.0}"/>
        <inertia
          ixx="${(mLidar/2.0) / 12.0 * (3*rLidar*rLidar + hLidar*hLidar)}" ixy="0.0" ixz="0.0"
          iyy="${(mLidar/2.0) / 12.0 * (3*rLidar*rLidar + hLidar*hLidar)}" iyz="0.0"
          izz="${(mLidar/2.0) / 2.0 * (rLidar*rLidar)}"/>
      </inertial>
      <visual>
        <origin rpy="0 0 0" xyz="0 0 0"/>
        <geometry>
          <cylinder length="${hLidar}" radius="${rLidar}"/>
        </geometry>
      </visual>
      <collision>
        <origin rpy="0 0 0 " xyz="0 0 0"/>
        <geometry>
          <cylinder length="${hLidar}" radius="${rLidar}"/>
        </geometry>
      </collision>
  </link>
  <gazebo reference="lidar_base_link">
    <material>Gazebo/Green</material>
  </gazebo>

  <joint name="lidar_base_joint" type="fixed">
    <origin rpy="0 0 0" xyz="${rChassis/2.0 + 0.02} -0.1 ${hChassis/2.0 + hLidar/2.0}"/>
    <parent link="base_link"/>
    <child link="lidar_base_link"/>
  </joint>

  <link name="lidar_top_link">
      <inertial>
        <origin rpy="0 0 0" xyz="0 0 0"/>
        <mass value="${mLidar/2.0}"/>
        <inertia
          ixx="${(mLidar/2.0) / 12.0 * (3*rLidar*rLidar + hLidar*hLidar)}" ixy="0.0" ixz="0.0"
          iyy="${(mLidar/2.0) / 12.0 * (3*rLidar*rLidar + hLidar*hLidar)}" iyz="0.0"
          izz="${(mLidar/2.0) / 2.0 * (rLidar*rLidar)}"/>
      </inertial>
      <visual>
        <origin rpy="0 0 0" xyz="0 0 0"/>
        <geometry>
          <cylinder length="${hLidar}" radius="${rLidar}"/>
        </geometry>
      </visual>
      <collision>
        <origin rpy="0 0 0 " xyz="0 0 0"/>
        <geometry>
          <cylinder length="${hLidar}" radius="${rLidar}"/>
        </geometry>
      </collision>
  </link>
  <gazebo reference="lidar_top_link">
    <material>Gazebo/Grey</material>
  </gazebo>

  <joint name="lidar_top_joint" type="continuous">
    <origin rpy="0 0 0" xyz="0 0 ${hLidar}"/>
    <parent link="lidar_base_link"/>
    <child link="lidar_top_link"/>
    <axis rpy="0 0 0" xyz="0 0 1"/>
    <limit effort="100" velocity="100"/>
    <joint_properties damping="0.0" friction="0.0"/>
  </joint>

  <gazebo reference="lidar_top_link">
    <sensor type="ray" name="lidar">
      <origin rpy="0 0 0 " xyz="${rLidar} 0 0"/>
      <visualize>true</visualize>
      <update_rate>30</update_rate>
      <topic>/terry/lidar_sensor</topic>
      <ray>
        <scan>
          <horizontal>
            <!-- The velodyne has 32 beams(samples) -->
            <samples>32</samples>
            <!-- Resolution is multiplied by samples to determine number of
                simulated beams vs interpolated beams. See:
                http://sdformat.org/spec?ver=1.6&elem=sensor#horizontal_resolution
                -->
            <resolution>1</resolution>
            <!-- Minimum angle in radians -->
            <min_angle>-0.53529248</min_angle>
            <!-- Maximum angle in radians -->
            <max_angle>0.18622663</max_angle>
          </horizontal>
          <vertical>
            <samples>32</samples>
            <resolution>1</resolution>
            <min_angle>-0.53529248</min_angle>
            <max_angle>0.18622663</max_angle>
          </vertical>
        </scan>
        <range>
          <min>0.05</min>
          <max>70.0</max>
          <resolution>0.02</resolution>
        </range>
        <noise>
          <!-- Use gaussian noise -->
          <type>gaussian</type>
          <mean>0.0</mean>
          <stddev>0.02</stddev>
        </noise>
      </ray>
      <plugin name="velodyne_control" filename="libvelodyne_plugin.so">
        <alwaysOn>true</alwaysOn>
        <updateRate>0.0</updateRate>
        <velocity>25</velocity>
        <topicName>/terry/lidar_plugin</topicName>
        <frameName>lidar_base_link</frameName>
      </plugin>
    </sensor>
  </gazebo>
  


    <!-- Differential drive controller for wheel odometry  -->
    <gazebo>
      <plugin filename="libgazebo_ros_diff_drive.so" name="differential_drive_controller_front">
        <rosDebugLevel>Debug</rosDebugLevel>
        <publishWheelTF>True</publishWheelTF>
        <publishTf>1</publishTf>
        <publishWheelJointState>true</publishWheelJointState>
        <alwaysOn>true</alwaysOn>
        <updateRate>100.0</updateRate>
        <leftJoint>left_wheel_joint</leftJoint>
        <rightJoint>right_wheel_joint</rightJoint>
        <wheelSeparation>${2*rChassis + hWheel}</wheelSeparation>
        <wheelDiameter>${2*rWheel}</wheelDiameter>
        <broadcastTF>1</broadcastTF>
        <!--<torque>30</torque>-->
        <!--<wheelAcceleration>1.8</wheelAcceleration>-->
        <commandTopic>/terry/cmd_vel</commandTopic>
        <odometryFrame>odom</odometryFrame>
        <odometryTopic>/terry/odom</odometryTopic>
        <robotBaseFrame>base_link</robotBaseFrame>
      </plugin>
    </gazebo>

    <!-- For ROS control -->
    <gazebo>
    <plugin name="gazebo_ros_control" filename="libgazebo_ros_control.so">
      <robotNamespace>/terry</robotNamespace>
    </plugin>
  </gazebo>

</robot>